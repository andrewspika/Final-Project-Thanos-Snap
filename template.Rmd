---
title: "Thanos Snap Template"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



1. Two of us handle the R side of things to develop and create simulations. Two of us learn how to make shiny apps

2. Investigate different add-ons to our simulation such as population size, allele frequency, generations, events, etc. and how they impact genetic drift.

3. Continue to learn shiny. Start to create test shiny apps.

4. Create simulations in R for genetic drift after a bottleneck event. Then translate that simulation into something user-friendly.

5. Finished product: Shiny app that simulates genetic drift after a bottleneck event.


```{r}
## Import libraries

source("https://github.com/mennodejong1986/SambaR/raw/master/SAMBAR_v1.09.txt")
library(tidyverse)
library(dplyr)


library(shiny)
library(ggplot2)
```



## Section One

```{r Andrew}
## One Generation of Survivors

# Total population for simulation
pop <- tibble(Trait = NA, Allele = NA, .rows = 100) #set .rows to 'population_size'

pop$Allele <- sample(c("AA", "Aa", "aa"), size=nrow(pop), replace=TRUE, prob=c(0.25, 0.5, 0.25))

# Random index for survival selection
survivors1 <- sample(1:nrow(pop), size = nrow(pop)/2)

# Keeping only the survivors
pop <- pop[survivors1,]

## Adding Generations

prop <- pop %>% group_by(Allele) %>% summarize(proportion = length(Allele)/nrow(pop))

```

```{r generation}
# Function to create a generation of offspring, or initial population
# Inputs: generation size 'size', alleles in genetic pool 'alleles', and allele proportion 'allele.prop'
# Outputs: tibble with a generation of offspring
create.generation <- 
  function(size=100, alleles=c("AA", "Aa", "aa"), allele.prop=c(.25,.5,.25)) {
  gen <- tibble(Trait = NA, Allele = NA, .rows = size)
  gen$Allele <- sample(alleles, size = size, prob = allele.prop, replace = TRUE)
    for(index in 1:nrow(gen)) {
     if(gen$Allele[index] == "AA" | gen$Allele[index] == "Aa") {
       gen$Trait[index] <- "Dominant"
     } else {
       gen$Trait[index] <- "Recessive"
     }
   }
  return(gen)
  }

# Test Function 'create.generation'
generation <- create.generation()

# Testing function still
initial.pop <- create.generation()

# Getting info from population
pop.info <- get.proportions(initial.pop)

# Creating another generation 'gen2' using population info
nextGen <- create.generation(size = nrow(initial.pop), alleles=pop.info$Allele, allele.prop = pop.info$prop)

# Possible binding of initial population with second generation
initial.pop <- initial.pop %>% rbind(nextGen)

## Replacing initial population with next generation
# initial.pop <- nextGen

```


```{r}
# Function to get alleles and allele proportions from population
# Inputs: tibble with alleles and proportions 'pop'
# Outputs: tibble with the alleles and their respective proportions from population
get.proportions <- function(pop) {
  proportions <- pop %>% group_by(Allele) %>% summarize(prop = length(Allele)/nrow(pop))
  return(proportions)
}
```

```{r}
## Sample simulation -- NOT DONE!!
# Function to simulate the generations
# Inputs: number of generations 'gens', default is 10, the starting allele frequency 'start.freq' ordered respective to 'AA', 'Aa', 'aa'. Also population size 'pop.size'
# Outputs: the resulting final generation of the simulation in a tibble
simulate.generations <- function(gens=10, start.freq=c(.25, .5, .25), pop.size=100) {
  population <- NULL
}
```

## Section Two

```{r Lucas}

```

## Section Three

```{r Noah}

```

## Section Four

```{r Dillon}

```
